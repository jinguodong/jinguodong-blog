<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>guodong.j</title>
    <link href="/jinguodong-blog/feed/" rel="self" />
    <link href="http://geeklu.com" />
    <lastBuildDate>2014-11-25T22:16:18+08:00</lastBuildDate>
    <webMaster>buptjinguodong@gmail.com</webMaster>
    
    <item>
      <title>Start - GitPages</title>
      <link href="/jinguodong-blog/2014/11/start-GitPages/"/>
      <pubDate>2014-11-25T00:00:00+08:00</pubDate>
      <author>guodong.j</author>
      <guid>/jinguodong-blog/2014/11/start-GitPages</guid>
      <content:encoded><![CDATA[]]></content:encoded>
    </item>
    
    <item>
      <title>JGD - hello, world</title>
      <link href="/jinguodong-blog/2014/11/hello-world/"/>
      <pubDate>2014-11-25T00:00:00+08:00</pubDate>
      <author>guodong.j</author>
      <guid>/jinguodong-blog/2014/11/hello-world</guid>
      <content:encoded><![CDATA[<h2>JGD - hello, world</h2>
<p> This is my first page.</p>
<p>25 Nov 2014</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Facebook Pop 使用指南</title>
      <link href="/jinguodong-blog/2014/05/facebook-pop-usage/"/>
      <pubDate>2014-05-22T00:00:00+08:00</pubDate>
      <author>guodong.j</author>
      <guid>/jinguodong-blog/2014/05/facebook-pop-usage</guid>
      <content:encoded><![CDATA[<p>当听闻Facebook要开源自己的Animation框架的时候，我还以为是基于Core Animation进行的封装，包含了一些动画效果库。等源码真正出来后，才发现完全想错了，Facebook Pop其实是基于CADisplayLink(Mac平台上使用的CVDisplayLink)实现的独立于Core Animation之外的动画方案。这里就不细说其实现原理了，主要讲讲Facebook Pop如何使用。</p>

<h2>一.基本概念</h2>

<p>在计算机的世界里面，其实并不存在绝对连续的动画，你所看到的屏幕上的动画本质上都是离散的，只是在一秒的时间里面离散的帧多到一定的数量人眼就觉得是连续的了，在iOS中，最大的帧率是60帧每秒。
iOS提供了Core Animation框架，只需要开发者提供关键帧信息，比如提供某个animatable属性终点的关键帧信息，然后中间的值则通过一定的算法进行插值计算，从而实现补间动画。 Core Aniamtion中进行插值计算所依赖的时间曲线由CAMediaTimingFunction提供。
Pop Animation在使用上和Core Animation很相似，都涉及Animation对象以及Animation的载体的概念，不同的是Core Animation的载体只能是CALayer，而Pop Animation可以是任意基于NSObject的对象。当然大多数情况Animation都是界面上显示的可视的效果，所以动画执行的载体一般都直接或者间接是UIView或者CALayer。但是如果你只是想研究Pop Animation的变化曲线，你也完全可以将其应用于一个普通的数据对象，比如下面这个对象:</p>

<pre><code>&lt;a href='https://github.com/interface' class='user-mention'&gt;@interface&lt;/a&gt; AnimatableModel : NSObject
&lt;a href='https://github.com/property' class='user-mention'&gt;@property&lt;/a&gt; (nonatomic,assign) CGFloat animatableValue;
&lt;a href='https://github.com/end' class='user-mention'&gt;@end&lt;/a&gt;

#import "AnimatableModel.h"
&lt;a href='https://github.com/implementation' class='user-mention'&gt;@implementation&lt;/a&gt; AnimatableModel
- (void)setAnimatableValue:(CGFloat)animatableValue{
  _animatableValue = animatableValue;
  NSLog(@"%f",animatableValue);
}

&lt;a href='https://github.com/end' class='user-mention'&gt;@end&lt;/a&gt;
</code></pre>

<p>此对象只有一个CGFloat类型的属性，非常简单，这里在AnimatableModel对象上运行几种Pop Animation进行测试，以便统计animatableValue的变化曲线。</p>

<p>由于此对象的属性不在Pop Property的标准属性中，所以需要创建一个POPAnimatableProperty，</p>

<pre><code>  POPAnimatableProperty *animatableProperty = [POPAnimatableProperty propertyWithName:@"com.geeklu.animatableValue" initializer:^(POPMutableAnimatableProperty *prop) {
    prop.writeBlock = ^(id obj, const CGFloat values[]) {
        [obj setAnimatableValue:values[0]];
    };
    prop.readBlock = ^(id obj, CGFloat values[]) {
        values[0] = [obj animatableValue];
    };
}];
</code></pre>

<p>统计的数据来自上面属性变化时的Log数据，制图的时候将时间中除了秒之外的时间部分删除了，所有数据都来自真实测试的数据，并使用Number进行了曲线的绘制。图中的每个点代表一个离散的节点，为了方便观看，使用直线将这些离散的点连接起来了。</p>

<p><img src="http://ww4.sinaimg.cn/mw1024/65cc0af7gw1ego7boez1uj20oc0icju4.jpg" style="width: 50%; height: 50%"/>​</p>

<h3>PopBasicAniamtion With EaseOut TimingFunction</h3>

<pre><code>POPBasicAnimation *animation = [POPBasicAnimation animation];
animation.property = animatableProperty;
animation.fromValue = [NSNumber numberWithFloat:0];
animation.toValue = [NSNumber numberWithFloat:100];
animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];
animation.duration = 1.5;

_animatableModel = [[AnimatableModel alloc] init];
[_animatableModel pop_addAnimation:animation forKey:@"easeOut"];
</code></pre>

<p><img src="http://ww1.sinaimg.cn/mw1024/65cc0af7gw1egnh3razkxj20sy0kadh2.jpg" style="width: 50%; height: 50%"/>​</p>

<p>从上图可以看到，动画开始的时候变化速率较快，到结束的时候就很慢了，这就是所谓的Ease Out效果。</p>

<h3>PopSpringAniamtion</h3>

<pre><code>POPSpringAnimation *animation = [POPSpringAnimation animation];
animation.property = animatableProperty;
animation.fromValue = [NSNumber numberWithFloat:0];
animation.toValue = [NSNumber numberWithFloat:100];
animation.dynamicsMass = 5;

_animatableModel = [[AnimatableModel alloc] init];
[_animatableModel pop_addAnimation:animation forKey:@"spring"];
</code></pre>

<p><img src="http://ww4.sinaimg.cn/mw1024/65cc0af7gw1egnh8m1lhtj20oi0gg0u4.jpg" style="width: 50%; height: 50%"/>​</p>

<p>一开始快速向终点方向靠近，然后会在终点附近来回摆动，摆动幅度逐渐变弱，最后在终点停止。</p>

<p>通过上面的两个属性值变化的曲线你可以很好的理解动画的类型和属性的变化曲线之前的关联了。</p>

<h2>二.Pop Animation的使用</h2>

<p>这里就讲讲Pop Aniamtion自带的几种动画的使用。 Pop Animation自带的动画都是基于POPPropertyAnimation的，POPPropertyAnimation有个很重要的部分就是 POPAnimatableProperty，用来描述animatable的属性。上一节中就看到了如何来创建一个POPAnimatableProperty对象，在初始化的时候，需要在初始化的block中设置writeBlock和readBlock</p>

<pre><code>void (^readBlock)(id obj, CGFloat values[])
void (^writeBlock)(id obj, const CGFloat values[])
</code></pre>

<p>这两个block都是留给动画引擎来使用的，前者用于向目标属性写值,使用者需要做的就是从values中提取数据设置给obj；后者用于读取，也就是从objc中读取放到values中。values[] 最多支持4个数据，也就是说Pop Aniamtion属性数值的维度最大支持4维。
为了使用便捷，Pop Animation框架提供了很多现成的POPAnimatableProperty预定义，你只需要使用预定义的propertyWithName来初始化POPAnimatableProperty便可，比如以下一些预定义的propertyWithName：</p>

<pre><code>kPOPLayerBackgroundColor
...
kPOPViewAlpha
...
</code></pre>

<p>这样预定义的POPAnimatableProperty已经帮你设置好writeBlock和readBlock。
下面的一些基于POPPropertyAnimation的动画都提供了快捷的方法，直接传入propertyWithName便创建好了特定property的动画了。
下面列举的各个实例都可以在这里找到：<a href="https://github.com/kejinlu/facebook-pop-sample">https://github.com/kejinlu/facebook-pop-sample</a>。</p>

<h3>1.POPBasicAnimation</h3>

<p>基本动画，接口方面和CABasicAniamtion很相似，使用可以提供初始值fromValue，这个 终点值toValue，动画时长duration以及决定动画节奏的timingFunction。timingFunction直接使用的CAMediaTimingFunction,是使用一个横向纵向都为一个单位的拥有两个控制点的贝赛尔曲线来描述的，横坐标为时间，纵坐标为动画进度。
<img src="http://ww2.sinaimg.cn/mw1024/65cc0af7gw1egpvtrn8qmj209307qdhf.jpg" style="width: 50%; height: 50%"/>​
这里举一个View移动的例子：</p>

<pre><code>NSInteger height = CGRectGetHeight(self.view.bounds);
NSInteger width = CGRectGetWidth(self.view.bounds);

CGFloat centerX = arc4random() % width;
CGFloat centerY = arc4random() % height;

POPBasicAnimation *anim = [POPBasicAnimation animationWithPropertyNamed:kPOPViewCenter];
anim.toValue = [NSValue valueWithCGPoint:CGPointMake(centerX, centerY)];
anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
anim.duration = 0.4;
[self.testView pop_addAnimation:anim forKey:@"centerAnimation"];
</code></pre>

<p>这里self.view上放了一个用于动画的testView，然后取一个随机坐标，进行动画。</p>

<h3>2.PopSpringAnimation</h3>

<p>弹簧动画是Bezier曲线无法表述的，所以无法使用PopBasicAniamtion来实现。PopSpringAnimation便是专门用来实现弹簧动画的。</p>

<pre><code>POPSpringAnimation *anim = [POPSpringAnimation animationWithPropertyNamed:kPOPViewCenter];

NSInteger height = CGRectGetHeight(self.view.bounds);
NSInteger width = CGRectGetWidth(self.view.bounds);

CGFloat centerX = arc4random() % width;
CGFloat centerY = arc4random() % height;

anim.toValue = [NSValue valueWithCGPoint:CGPointMake(centerX, centerY)];
anim.springBounciness = 16;
anim.springSpeed = 6;
[self.testView pop_addAnimation:anim forKey:@"center"];
</code></pre>

<p><img src="http://ww1.sinaimg.cn/mw1024/65cc0af7gw1egqpgva69rg208u0fpjtx.gif" style="width: 25%; height: 25%";/>​</p>

<p>这个例子的动画和上面的基本动画很相似，都是一个view的移动，但是这里有弹簧效果。POPSpringAnimation主要就是需要注意下几个参数的含义：</p>

<ul>
<li>springBounciness 弹簧弹力 取值范围为[0, 20]，默认值为4</li>
<li>springSpeed 弹簧速度，速度越快，动画时间越短 [0, 20]，默认为12，和springBounciness一起决定着弹簧动画的效果</li>
<li>dynamicsTension  弹簧的张力</li>
<li>dynamicsFriction 弹簧摩擦</li>
<li>dynamicsMass 质量  。张力，摩擦，质量这三者可以从更细的粒度上替代springBounciness和springSpeed控制弹簧动画的效果</li>
</ul>


<h3>3.PopDecayAnimation</h3>

<p>基于Bezier曲线的timingFuntion同样无法表述Decay Aniamtion，所以Pop就单独实现了一个 PopDecayAnimation，用于衰减动画。衰减动画一个很常见的地方就是 UIScrollView 滑动松开后的减速，这里就基于UIView实现一个自己的ScrollView，然后使用PopDecayAnimation实现
此代码可以详细参见 <a href="https://github.com/kejinlu/facebook-pop-sample/blob/master/facebook-pop-sample/KKScrollView.m">KKScrollView</a> 的实现，当滑动手势结束时，根据结束的加速度，给衰减动画一个初始的velocity，用来决定衰减的时长。</p>

<p><img src="http://ww3.sinaimg.cn/mw1024/65cc0af7gw1egmzoapnqwg206i0bm7nn.gif" style="width: 25%; height: 25%";/>​</p>

<h3>4.POPCustomAnimation</h3>

<p>POPCustomAnimation 并不是基于POPPropertyAnimation的，它直接继承自PopAnimation用于创建自定义动画用的，通过POPCustomAnimationBlock类型的block进行初始化，</p>

<pre><code>typedef BOOL (^POPCustomAnimationBlock)(id target, POPCustomAnimation *animation);
</code></pre>

<p>此block会在界面的每一帧更新的时候被调用，创建者需要在block中根据当前currentTime和elapsedTime来决定如何更新target的相关属性，以实现特定的动画。当你需要结束动画的时候就在block中返回NO，否则返回YES。</p>

<h2>四.Pop Animation相比于Core Animation的优点</h2>

<p>Pop Animation应用于CALayer时，在动画运行的任何时刻，layer和其presentationLayer的相关属性值始终保持一致，而Core Animation做不到。 <br/>
Pop Animation可以应用任何NSObject的对象，而Core Aniamtion必须是CALayer。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Custom Container View Controller</title>
      <link href="/jinguodong-blog/2014/05/custom-container-view-controller/"/>
      <pubDate>2014-05-08T00:00:00+08:00</pubDate>
      <author>guodong.j</author>
      <guid>/jinguodong-blog/2014/05/custom-container-view-controller</guid>
      <content:encoded><![CDATA[<p>什么是Container View Controller?苹果文档是这么描述的:</p>

<pre><code>A container view controller contains content owned by other view controllers.
</code></pre>

<p>也就是说一个View Controller显示的某部分内容属于另一个View Controller，那么这个View Controller就是一个Container，比如UIKit中的UINavigationController，UITabBarController。 <br/>
在iOS 5之前苹果是不允许出现自定义的Container的 ，也就是说你创建的一个View Controller的view不能包含另一个View Controller的view，这对于逻辑复杂的界面来说，不易于功能拆分。也许曾经你为了某个公用的显示逻辑，直接将某个View Controller的view添加到另一个View Controller的view上，然后发现可以正常显示和使用，但实际上这种行为是非常危险的。</p>

<p>iOS 5.0 开始支持Custom Container View Controller，开放了用于构建自定义Container的接口。如果你想创建一个自己的Container，那么有一些概念还得弄清楚。Container的主要职责就是管理一个或多个Child View Controller的展示的生命周期，需要传递显示以及旋转相关的回调。其实显示或者旋转的回调的触发的源头来自于window,一个app首先有一个主window，初始化的时候需要给这个主window指定一个rootViewController，window会将显示相关的回调(viewWillAppear:, viewWillDisappear:, viewDidAppear:, or viewDidDisappear: )以及旋转相关的回调(willRotateToInterfaceOrientation:duration:
,willAnimateRotationToInterfaceOrientation:duration:,
didRotateFromInterfaceOrientation:)传递给rootViewController。rootViewController需要再将这些callbacks的调用传递给它的Child View Controllers。</p>

<h3>一.父子关系范式</h3>

<p>实现一个Custom Container View Controller并不是一个简单的事情，主要分为两个阶段：父子关系的建立以及父子关系的解除。如果pVC将cVC的view添加为自己的subview，那么cVC必须为pVC的Child View Controller，而反过来则不一定成立，比如UINavigationController，一个View Controller被push进来后便和navigationController建立父子关系了,但是只有最上面的View Controller 是显示着的，底下的View Controller的view则被移出了容器的view的显示层级，当一个View Controller被pop之后，便和navigationController解除了父子关系了。</p>

<p><strong>展示一个名为content的child view controller</strong>：</p>

<pre><code> [self addChildViewController:content];  //1
 content.view.frame = [self frameForContentController]; 
 [self.view addSubview:self.currentClientView]; //2
 [content didMoveToParentViewController:self]; //3
</code></pre>

<p>1.将content添加为child view controller，addChildViewController:接口建立了逻辑上的父子关系，子可以通过parentViewController，访问其父VC，addChildViewController:接口的逻辑中会自动调用 <code>[content willMoveToParentViewController:self];</code><br/>
2.建立父子关系后，便是将content的view加入到父VC的view hierarchy上，同时要决定的是 content的view显示的区域范围。 <br/>
3.调用child的 didMoveToParentViewController: ，以通知child，完成了父子关系的建立</p>

<p><strong>移除一个child view controller</strong>：</p>

<pre><code> [content willMoveToParentViewController:nil]; //1
 [content.view removeFromSuperview]; //2
 [content removeFromParentViewController]; //3
</code></pre>

<p>1.通知child，即将解除父子关系，从语义上也可以看出 child的parent即将为nil<br/>
2.将child的view从父VC的view的hierarchy中移除 <br/>
3.通过removeFromParentViewController的调用真正的解除关系，removeFromParentViewController会自动调用 [content didMoveToParentViewController:nil]</p>

<h3>二.appearance callbacks的传递</h3>

<p>上面的实现中有一个问题，就是没看到那些appearance callbacks是如何传递的，答案就是appearance callbacks默认情况下是自动调用的，苹果框架底层帮你实现好了，也就是在上面的addSubview的时候，在subview真正加到父view之前，child的viewWillAppear将被调用，真正被add到父view之后，viewDidAppear会被调用。移除的过程中viewWillDisappear，viewDidDisappear的调用过程也是类似的。<br/>
有时候自动的appearance callbacks的调用并不能满足需求，比如child view的展示有一个动画的过程，这个时候我们并不想viewDidAppear的调用在addSubview的时候进行，而是等展示动画结束后再调用viewDidAppear。也许你可能会提到 <code>transitionFromViewController:toViewController:duration:options:animations:completion:</code> 这个方法，会帮你自动处理view的add和remove，以及支持animations block，也能够保证在动画开始前调用willAppear或者willDisappear，在调用结束的时候调用didAppear，didDisappear，但是此方式也存在局限性，必须是两个新老子VC的切换，都不能为空，因为要保证新老VC拥有同一个parentViewController，且参数中的viewController不能是系统中的container，比如不能是UINavigationController或者UITabbarController等。  <br/>
所以如果你要自己写一个界面容器往往用不了appearence callbacks自动调用的特性，需要将此特性关闭，然后自己去精确控制appearance callbacks的调用时机。 <br/>
那如何关闭appearance callbacks的自动传递的特性呢？在iOS 5.x中你需要覆盖<code>automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers</code>,然后返回NO,iOS6+中你需要覆盖 <code>shouldAutomaticallyForwardAppearanceMethods</code>方法并返回NO. <br/>
手动传递的时候你并不能直接去调用child 的viewWillAppear或者viewDidAppear这些方法，而是需要使用 <code>beginAppearanceTransition:animated:</code>和<code>endAppearanceTransition</code>接口来间接触发那些appearance callbacks，且begin和end必须成对出现。 <br/>
<code>[content beginAppearanceTransition:YES animated:animated]</code>触发content的viewWillAppear，<code>[content beginAppearanceTransition:NO animated:animated]</code>触发content的viewWillDisappear，和他们配套的[content endAppearanceTransition]分别触发viewDidAppear和viewDidDisappear。  (AppearanceTransition的这两个接口之前在苹果描述的文档中一开始还存在问题，因为文档中一开始说是iOS5不支持这两个接口，其实是支持的，后来苹果纠正了文档中的这个错误)。</p>

<h3>三.rotation callbacks的传递</h3>

<p>也许在iPhone上很少要关心的屏幕旋转问题的，但是大屏幕的iPad上就不同了，很多时候你需要关心横竖屏。rotation callbacks 一般情况下只需要关心三个方法
<code>willRotateToInterfaceOrientation:duration:</code>在旋转开始前，此方法会被调用；<code>willAnimateRotationToInterfaceOrientation:duration:</code> 此方法的调用在旋转动画block的内部，也就是说在此方法中的代码会作为旋转animation block的一部分；<code>didRotateFromInterfaceOrientation:</code>此方法会在旋转结束时被调用。而作为view controller container 就要肩负起旋转的决策以及旋转的callbacks的传递的责任。</p>

<p>当使用框架的自动传递的特性的时候，作为容器的view controller 会自动
将这些方法传递给所有的child viewcontrollers， 有时候你可能不需要传递给所有的child viewcontroller，而只需要传递给正在显示的child viewcontroller，那么你就需要禁掉旋转回调自动传递的特性，和禁掉appearance callbacks自动传递的方式类似，需要覆盖相关方法并返回NO，在iOS5.x中，appearance callbacks和rotation callbacks禁掉是公用一个方法的就是 <code>automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers</code>，在iOS6之后分成两个独立的方法，旋转的则是 <code>shouldAutomaticallyForwardRotationMethods</code>。 <br/>
旋转相关的除了上面的几个rotation callbacks方法外，还有一个十分重要的概念，就是一个view controller可以决定自己是否支持当前取向的旋转，这个东西在iOS6前后的实现方式还不一样，iOS6之前使用的方法是 <code>shouldAutorotateToInterfaceOrientation</code>，就是一个view controller覆盖此方法，根据传入的即将旋转的取向的参数，来决定是否旋转。而iOS6.0之后的实现则拆分成两个方法 <code>shouldAutorotate</code>和<code>supportedInterfaceOrientations</code>,前者决定再旋转的时候是否去根据<code>supportedInterfaceOrientations</code>所支持的取向来决定是否旋转，也就是说如果<code>shouldAutorotate</code>返回YES的时候，才会去调用<code>supportedInterfaceOrientations</code>检查当前view controller支持的取向，如果当前取向在支持的范围中，则进行旋转，如果不在则不旋转；而当<code>shouldAutorotate</code>返回NO的时候，则根本不会去管<code>supportedInterfaceOrientations</code>这个方法，反正是不会跟着设备旋转就是了。 <br/>
而作为界面容器你要注意的就是你需要去检查你的child view controller，检查他们对横竖屏的支持情况，以便容器自己决策在横竖屏旋转时候是否支持当前的取向，和上面的callbacks传递的方向相比，这其实是一个反向的传递。</p>

<h3>四.创建自己的容器基类</h3>

<p>当你需要构建自己的Container View Controller的时候，每一个Container都会有一些相同的逻辑，如果你每一个都写一遍会存在很多重复代码，所以最好你创建一个Container基类，去实现容器都需要的逻辑。那到底有哪些逻辑是每一个Container都需要做的呢？关闭Appearance和Rotation相关方法的自动传递；当Container的Appearance和Rotation相关方法被调用时，需要将方法传递给相关的Child View Controller；以及当前Container是否支持旋转的决策逻辑等。下面为一个容器基类的示范:</p>

<pre><code>#import "ContainerBaseController.h"

&lt;a href='https://github.com/implementation' class='user-mention'&gt;@implementation&lt;/a&gt; ContainerBaseController

#pragma mark -
#pragma mark Overrides
//NS_DEPRECATED_IOS(5_0,6_0)
- (BOOL)automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers{
return NO;
}

//NS_AVAILABLE_IOS(6_0)
- (BOOL)shouldAutomaticallyForwardAppearanceMethods{
    return NO;
}

//NS_AVAILABLE_IOS(6_0)
- (BOOL)shouldAutomaticallyForwardRotationMethods{
return NO;
}

- (void)viewWillAppear:(BOOL)animated{
    [super viewWillAppear:animated];

    NSArray *viewControllers = [self childViewControllersWithAppearanceCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
        [viewController beginAppearanceTransition:YES animated:animated];
    }
}

- (void)viewDidAppear:(BOOL)animated{
    [super viewDidAppear:animated];

    NSArray *viewControllers = [self childViewControllersWithAppearanceCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
        [viewController endAppearanceTransition];
    }
}

- (void)viewWillDisappear:(BOOL)animated{
    [super viewWillDisappear:animated];

    NSArray *viewControllers = [self childViewControllersWithAppearanceCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
        [viewController beginAppearanceTransition:NO animated:animated];
    }
}

- (void)viewDidDisappear:(BOOL)animated{
    [super viewDidDisappear:animated];

    NSArray *viewControllers = [self childViewControllersWithAppearanceCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
        [viewController endAppearanceTransition];
    }
}


- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration{
    [super willRotateToInterfaceOrientation:toInterfaceOrientation duration:duration];

    NSArray *viewControllers = [self childViewControllersWithRotationCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
        [viewController willRotateToInterfaceOrientation:toInterfaceOrientation duration:duration];

}
}

- (void)willAnimateRotationToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration{
    [super willAnimateRotationToInterfaceOrientation:toInterfaceOrientation duration:duration];

    NSArray *viewControllers = [self childViewControllersWithRotationCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
            [viewController willAnimateRotationToInterfaceOrientation:toInterfaceOrientation duration:duration];
    }
}

- (void)didRotateFromInterfaceOrientation:(UIInterfaceOrientation)fromInterfaceOrientation{
    [super didRotateFromInterfaceOrientation:fromInterfaceOrientation];

    NSArray *viewControllers = [self childViewControllersWithRotationCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
        [viewController didRotateFromInterfaceOrientation:fromInterfaceOrientation];
    }
}

/*
 NS_AVAILABLE_IOS(6_0) 
 向下查看和旋转相关的ChildViewController的shouldAutorotate的值
 只有所有相关的子VC都支持Autorotate，才返回YES
 */
- (BOOL)shouldAutorotate{
    NSArray *viewControllers = [self childViewControllersWithRotationCallbackAutoForward];
    BOOL shouldAutorotate = YES;
    for (UIViewController *viewController in viewControllers) {
        shouldAutorotate = shouldAutorotate &amp;&amp;  [viewController shouldAutorotate];
    }

    return shouldAutorotate;
}

/*
 NS_AVAILABLE_IOS(6_0) 
 此方法会在设备旋转且shouldAutorotate返回YES的时候才会被触发
 根据对应的所有支持的取向来决定是否需要旋转
 作为容器，支持的取向还决定于自己的相关子ViewControllers
 */
- (NSUInteger)supportedInterfaceOrientations{
    NSUInteger supportedInterfaceOrientations = UIInterfaceOrientationMaskAll;

    NSArray *viewControllers = [self childViewControllersWithRotationCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
        supportedInterfaceOrientations = supportedInterfaceOrientations &amp; [viewController supportedInterfaceOrientations];
    }

    return supportedInterfaceOrientations;
}


/*
 NS_DEPRECATED_IOS(2_0, 6_0) 6.0以下，设备旋转时，此方法会被调用
 用来决定是否要旋转
 */
- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation{
    BOOL shouldAutorotate = YES;
    NSArray *viewControllers = [self childViewControllersWithRotationCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
    shouldAutorotate = shouldAutorotate &amp;&amp;  [viewController shouldAutorotateToInterfaceOrientation:toInterfaceOrientation];
    }
    return shouldAutorotate;
}

#pragma mark -
#pragma mark 下面两个方法是在需要的情况下给基类覆盖用的，毕竟不是所有的容器都需要将相关方法传递给所有的childViewControllers
- (NSArray *)childViewControllersWithAppearanceCallbackAutoForward{
    return self.childViewControllers;
}

- (NSArray *)childViewControllersWithRotationCallbackAutoForward{
    return self.childViewControllers;
}

&lt;a href='https://github.com/end' class='user-mention'&gt;@end&lt;/a&gt;
</code></pre>

<h3>五.创建自己的Container</h3>

<h4>设计要点</h4>

<p>创建一个Container，首先你得设计好Container View Controller的行为和公开的API，你可以好好参考UIKit中自带的一些Container的设计风格，比如UINaivgationController就是管理着一组Content View Controller的堆栈的Container,且正在显示的是栈顶的View Controller。</p>

<p>主要接口有View Controller的推入，此过程中viewController会和navigationController建立父子关系，并将viewController显示出来，如果animated是YES的话，则会有过场动画：</p>

<pre><code>- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated
</code></pre>

<p>pop操作，移除栈顶的内容，会解除和navigationController的父子关系：</p>

<pre><code>- (UIViewController *)popViewControllerAnimated:(BOOL)animated;
</code></pre>

<p>当然关于pop还有一些其他的便捷接口，这里就不赘述了。</p>

<p>另外需要提供一些快捷的接口方便<strong>获取特定的Child View Controller</strong>，比如<code>topViewController</code>可以获取栈顶的View Controller。</p>

<p>另外如有必要，Container还需要留有<strong>delegate接口</strong>，便于通知外面Container的相关行为阶段，便于外部做出相关操作，比如UINaivgationController就会在即将要push一个新的View Controller，已经push了一个新的View Controller等时机留有delegate方法。</p>

<p>还有一个需要考虑的问题就是直接或者间接的Child View Controller如何快速的<strong>检索</strong>到相应的Container呢？一般Container在实现的时候就需要考虑此问题并提供相应的接口，实现的方法一般就是实现一个UIViewController的Category，比如UINavigationController，在某个View Controller中访问其navigationController属性，会向上遍历，直到找到最近的类型为UINavigationController的祖先，如果找不到则为nil：</p>

<pre><code>&lt;a href='https://github.com/interface' class='user-mention'&gt;@interface&lt;/a&gt; UIViewController (UINavigationControllerItem)
...
&lt;a href='https://github.com/property' class='user-mention'&gt;@property&lt;/a&gt;(nonatomic,readonly,retain) UINavigationController *navigationController;

&lt;a href='https://github.com/end' class='user-mention'&gt;@end&lt;/a&gt;
</code></pre>

<h4>实现一个简单的模态窗口Container</h4>

<p>模态展示 则至少存在present，dismiss的接口，以及获取模态View Controller的属性</p>

<pre><code>#import &lt;UIKit/UIKit.h&gt;
#import "ContainerBaseController.h"

&lt;a href='https://github.com/interface' class='user-mention'&gt;@interface&lt;/a&gt; SimpleModalContainerController : ContainerBaseController

&lt;a href='https://github.com/property' class='user-mention'&gt;@property&lt;/a&gt; (nonatomic, readonly) UIViewController *simpleModalViewController;

- (void)presentSimpleModalViewController:(UIViewController *)viewControllerToPresent
                            animated:(BOOL)animated;

- (void)dismissSimpleModalViewControllerAnimated:(BOOL)animated;

&lt;a href='https://github.com/end' class='user-mention'&gt;@end&lt;/a&gt;

//实现如下
#import "SimpleModalContainerController.h"

&lt;a href='https://github.com/interface' class='user-mention'&gt;@interface&lt;/a&gt; SimpleModalContainerController ()
&lt;a href='https://github.com/property' class='user-mention'&gt;@property&lt;/a&gt; (nonatomic, readwrite) UIViewController *simpleModalViewController;
&lt;a href='https://github.com/property' class='user-mention'&gt;@property&lt;/a&gt; (nonatomic, strong) UIButton *backgroundButton;
&lt;a href='https://github.com/end' class='user-mention'&gt;@end&lt;/a&gt;

&lt;a href='https://github.com/implementation' class='user-mention'&gt;@implementation&lt;/a&gt; SimpleModalContainerController

- (void)buttonTapped:(id)sender{
    [self dismissSimpleModalViewControllerAnimated:YES];
}

- (UIButton *)backgroundButton{
    if (!_backgroundButton) {
        _backgroundButton = [UIButton buttonWithType:UIButtonTypeCustom];
        _backgroundButton.backgroundColor = [UIColor blackColor];
        _backgroundButton.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
        _backgroundButton.alpha = 0.3;
        [_backgroundButton addTarget:self action:&lt;a href='https://github.com/selector' class='user-mention'&gt;@selector&lt;/a&gt;(buttonTapped:) forControlEvents:UIControlEventTouchUpInside];

    }
    _backgroundButton.frame = self.view.bounds;
    return _backgroundButton;
}

- (void)presentSimpleModalViewController:(UIViewController *)viewControllerToPresent
                            animated:(BOOL)animated{
    if (!self.simpleModalViewController &amp;&amp; viewControllerToPresent) {
        self.simpleModalViewController = viewControllerToPresent;

        [self addChildViewController:viewControllerToPresent];

        [viewControllerToPresent beginAppearanceTransition:YES animated:animated];

        [self.view addSubview:self.backgroundButton];

        viewControllerToPresent.view.center = CGPointMake(CGRectGetWidth(self.view.bounds) / 2.0, CGRectGetHeight(self.view.bounds) / 2.0);
        [self.view addSubview:viewControllerToPresent.view];

        if (animated) {
            viewControllerToPresent.view.alpha = 0;
            self.backgroundButton.alpha = 0;

            [UIView animateWithDuration:0.3 animations:^{
                viewControllerToPresent.view.alpha = 1;
                self.backgroundButton.alpha = 0.3;
            } completion:^(BOOL finished) {
                [viewControllerToPresent endAppearanceTransition];
                [viewControllerToPresent didMoveToParentViewController:self];
            }];
        } else {
            self.backgroundButton.alpha = 0.3;
            [viewControllerToPresent endAppearanceTransition];
            [viewControllerToPresent didMoveToParentViewController:self];
        }

    }
}

- (void)dismissSimpleModalViewControllerAnimated:(BOOL)animated{
    if (self.simpleModalViewController) {
        [self.simpleModalViewController willMoveToParentViewController:nil];
        [self.simpleModalViewController beginAppearanceTransition:NO animated:animated];

        if (animated) {
            [UIView animateWithDuration:0.3 animations:^{
                self.backgroundButton.alpha = 0;
                self.simpleModalViewController.view.alpha = 0 ;
            } completion:^(BOOL finished) {
                [self.backgroundButton removeFromSuperview];

                [self.simpleModalViewController.view removeFromSuperview];
                self.simpleModalViewController.view.alpha = 1.0;
                [self.simpleModalViewController endAppearanceTransition];
                [self.simpleModalViewController removeFromParentViewController];
                self.simpleModalViewController = nil;
            }];
        } else {
            [self.backgroundButton removeFromSuperview];

            [self.simpleModalViewController.view removeFromSuperview];
            self.simpleModalViewController.view.alpha = 1.0;
            [self.simpleModalViewController endAppearanceTransition];
            [self.simpleModalViewController removeFromParentViewController];
            self.simpleModalViewController = nil;
        }
    }
}

&lt;a href='https://github.com/end' class='user-mention'&gt;@end&lt;/a&gt;
</code></pre>

<p>UIViewController的Category用于Child View Controller 获取上层的SimpleModalContainerController</p>

<pre><code>&lt;a href='https://github.com/interface' class='user-mention'&gt;@interface&lt;/a&gt; UIViewController (SimpleModalContainerController)

&lt;a href='https://github.com/property' class='user-mention'&gt;@property&lt;/a&gt; (nonatomic, readonly) SimpleModalContainerController *simpleModalContainerController;

&lt;a href='https://github.com/end' class='user-mention'&gt;@end&lt;/a&gt;

&lt;a href='https://github.com/implementation' class='user-mention'&gt;@implementation&lt;/a&gt; UIViewController (SimpleModalContainerController)

- (SimpleModalContainerController *)simpleModalContainerController{
    for (UIViewController *viewController = self.parentViewController; viewController != nil; viewController = viewController.parentViewController) {
        if ([viewController isKindOfClass:[SimpleModalContainerController class]]) {
            return (SimpleModalContainerController *)viewController;
        }
    }
    return nil;
}

&lt;a href='https://github.com/end' class='user-mention'&gt;@end&lt;/a&gt;
</code></pre>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
