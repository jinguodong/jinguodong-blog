<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>guodong.j</title>
    <link href="/jinguodong-blog/feed/" rel="self" />
    <link href="http://geeklu.com" />
    <lastBuildDate>2015-03-20T18:06:28+08:00</lastBuildDate>
    <webMaster>buptjinguodong@gmail.com</webMaster>
    
    <item>
      <title>研究生毕业</title>
      <link href="/jinguodong-blog/2015/03/graduate-list/"/>
      <pubDate>2015-03-10T00:00:00+08:00</pubDate>
      <author>guodong.j</author>
      <guid>/jinguodong-blog/2015/03/graduate-list</guid>
      <content:encoded><![CDATA[<h2>毕业手续列表</h2>

<ol>
<li>进入“学位”→“毕业学位”→“就业情况信息登记”一栏，填写相关信息并保存；最后进入“学位”→“毕业学位”→“学位授予信息核对”栏，核实各项信息后下载打印《学位授予信息表》并签字。硕士研究生应于所在学院规定的时间内，凭本人签字的《学位授予信息表》到学院教务科领取学位证书。</li>
</ol>


<p>特别提示：</p>

<p>1、就业情况信息登记中：“去向”、“就业单位”、“单位类别”、“工作性质”、“单位所在省市”为必填项。</p>

<p>2、研究生学历电子注册之后方可发放毕业证、派遣证以及讨论学位授予问题。学生本人无需参与学历电子注册流程，只需按照学生所在学院（研究所、中心）的时间要求完成学位论文答辩，并将答辩材料递交至本学院（研究所、中心）即可。后续可关注研究生院网站公布的学历电子注册名单，公布名单后学生可向学生处咨询毕业证书问题。</p>

<p>3、未能参加本次毕业的学生，可于2015年7月毕业。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>工作选择</title>
      <link href="/jinguodong-blog/2015/03/micro-or-bank/"/>
      <pubDate>2015-03-08T00:00:00+08:00</pubDate>
      <author>guodong.j</author>
      <guid>/jinguodong-blog/2015/03/micro-or-bank</guid>
      <content:encoded><![CDATA[<h2>微软</h2>

<ol>
<li>发展好</li>
<li>户口（不是100%）</li>
<li>薪水一般多</li>
<li>条件好</li>
<li>工作强度较大</li>
<li>压力大</li>
</ol>


<h2>建行北开(Chosed)</h2>

<ol>
<li>户口（100%)</li>
<li>发展差</li>
<li>稳定</li>
<li>压力小</li>
</ol>


<h2>1年之后的总结</h2>

<p>待补充</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>研究生毕业论文答辩PPT主线</title>
      <link href="/jinguodong-blog/2015/02/postgraduate-paper-ppt-metadata/"/>
      <pubDate>2015-02-21T00:00:00+08:00</pubDate>
      <author>guodong.j</author>
      <guid>/jinguodong-blog/2015/02/postgraduate-paper-ppt-metadata</guid>
      <content:encoded><![CDATA[<h2>基本理论</h2>

<h3>希望听众能够。。。</h3>

<ol>
<li>了解什么？</li>
<li>记住什么？</li>
<li>做些什么？</li>
</ol>


<p>设定目标（SMART原则）
Specific（明确性）
Measurable（可衡量性）
Attainable（可达成性）
Relevant（相关性）
Time-bound（时限性）
分析听众
找准核心听众
预判听众立场
了解听众痒点
考虑部门立场
考虑听众个性
考虑演讲场合
分析听众-主题
好主题写在封面上
点出演示主题
抓住人的眼球
制造兴奋点
封面-标题
用数字给标题添光彩
想畅销书学标题
向热门流行语要标题
活动联想与双关联想
封面-配图
整体构思
线索
时间线
空间线
习惯结构
经典框架
目录
3-5个单元
让观众知道准备花多少时间讲每个内容
带时间线目录
组织材料
页面标题要抢眼球
页面文字要简洁
删除废话
挖关键词
不用标点断句
内容有结构
好材料要视觉化
抽象信息具象化
强调关键字</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>iscroll-5学习笔记</title>
      <link href="/jinguodong-blog/2015/02/iscroll-5/"/>
      <pubDate>2015-02-12T00:00:00+08:00</pubDate>
      <author>guodong.j</author>
      <guid>/jinguodong-blog/2015/02/iscroll-5</guid>
      <content:encoded><![CDATA[
]]></content:encoded>
    </item>
    
    <item>
      <title>提高前段开发效率的那些事(转载)</title>
      <link href="/jinguodong-blog/2015/02/Effective-FrontPart/"/>
      <pubDate>2015-02-12T00:00:00+08:00</pubDate>
      <author>guodong.j</author>
      <guid>/jinguodong-blog/2015/02/Effective-FrontPart</guid>
      <content:encoded><![CDATA[<p>转载自：<a href="http://www.kuqin.com/shuoit/20150205/344733.html">提高前段开发效率的那些事</a></p>

<h2>选一个好用的编辑器，并熟练使用她（他）</h2>

<p>在我看来好用的编辑器至少有以下功能</p>

<ol>
<li>语法高亮</li>
<li>括号匹配</li>
<li>能快速定位</li>
<li>快速打开文件</li>
<li>在文件中查找</li>
<li>在文件夹中查找</li>
<li>跳至某一行</li>
<li>能安装插件</li>
</ol>


<h2>能熟练用浏览器进行调试</h2>

<p>主要包括</p>

<ol>
<li>审查元素</li>
<li>打断点和条件断点</li>
<li>改变元素的状态，例如：hover,focus</li>
<li>熟练的使用浏览器的控制台</li>
</ol>


<h2>确定项目模板</h2>

<p>(试用了一下，感觉不太好用)
问题：
1. 是不是这个项目的最大贡献就是解决了index.html的兼容性问题？</p>

<p>推荐在<a href="http://www.bootcss.com/p/html5boilerplate/">HTML5 BOILERPLATE</a>上做一些自己的定制。
如果是移动端的项目，推荐用MOBILE BOILERPLATE。</p>

<h2>能快速的生成模板项目</h2>

<p>推荐使用Yo。(没找到)</p>

<h2>创建一个项目的组件页</h2>

<p>可以参考bootstrap的。见<a href="http://v3.bootcss.com/components/">这里</a></p>

<h2>积累一些的高质量的常用第三方组件，并自己写一些使用组件的demo</h2>

<p>网上总是不缺各种第三方组件。其中不乏很多带很多坑的组件。所以，发现高质量的组件，那就赶紧mark吧。我积累了一些，见<a href="https://github.com/iamjoel/front-end-plugins">这里</a>。</p>

<p>虽然很多组件都有官方写的demo。但看官方的demo总是需要花一些时间去理解。我的做法是，理解了官方的demo后，自己也写一些demo。那以后再次使用时，就可以看自己写的demo了。</p>

<h2>积累些常用的代码片段</h2>

<p>类似http://css-tricks.com/snippets/。</p>

<p>如果编辑器是用的sublime的话，可以创建代码片段(snippets)。要再用的时候，只需输入几个键，就可以将代码片段输出。</p>

<h2>积累的一些前段技术文献</h2>

<ol>
<li><a href="http://www.w3cplus.com/">W3CPlus</a></li>
<li><a href="http://www.w3cplus.com/source/10-best-Parallax-Scrolling-plugin.html">10个优秀视差滚动插件</a></li>
</ol>


<h2>其他</h2>

<p>还有一些，待探究</p>

<p>项目的依赖管理(bower之类)
预编译（less，coffee之类），后编译（postcss之类）
GTD（Get things done）
最后，推荐一个Chrome插件livestyle。有了它，不用刷新，在chrome中改的css会同步修改到文件，在文件中修改的css也会同步到浏览器。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>精彩绝伦的jQuery</title>
      <link href="/jinguodong-blog/2015/02/Smashing-jQuery/"/>
      <pubDate>2015-02-09T00:00:00+08:00</pubDate>
      <author>guodong.j</author>
      <guid>/jinguodong-blog/2015/02/Smashing-jQuery</guid>
      <content:encoded><![CDATA[<h2>需要解决的问题</h2>

<ol>
<li>鼠标滚动事件处理。</li>
<li>图片块区滚动效果处理。</li>
<li>JavaScript实现网站模块式开发。</li>
</ol>


<h1>第一部分 简介</h1>

<h1>第二部分 jQuery基础</h1>

<p>主要内容：</p>

<ol>
<li>jQuery核心：选择器、过滤器及CSS</li>
<li>事件</li>
<li>用特效为Web站点添色</li>
</ol>


<h2>第3章 jQuery核心：选择器、过滤器及CSS</h2>

<pre><code>再补充
</code></pre>

<h2>第4章 事件</h2>
]]></content:encoded>
    </item>
    
    <item>
      <title>jQuery基础教程(第3版)</title>
      <link href="/jinguodong-blog/2015/02/Learning-jQuery/"/>
      <pubDate>2015-02-08T00:00:00+08:00</pubDate>
      <author>guodong.j</author>
      <guid>/jinguodong-blog/2015/02/Learning-jQuery</guid>
      <content:encoded><![CDATA[<h2>需要解决的问题</h2>

<ol>
<li>带发掘。</li>
</ol>


<h2>第1章 jQuery入门</h2>

<h2>第2章 选择元素</h2>

<h3>本章内容</h3>

<ol>
<li>CSS和XPath选择符</li>
<li>jQuery独有的自定义选择符</li>
<li>jQuery的DOM遍历方法</li>
</ol>


<h3>$()函数</h3>

<p>基本的选择符</p>

<p>|| <em>选择符</em> || <em>CSS</em> || <em>jQuery</em> || <em>说明</em> ||
|| 标签名 || p {} || $('p') || 取得文档中所有的段落 ||
|| ID || #some-id {} || $('#some-id') || 取得文档中ID为some-id的一个元素 ||
|| 类 || .some-class {} || #('.some-class') || 取得文档中类为some-class的所有元素 ||</p>

<h2>第3章 事件</h2>

<h3>本章内容</h3>

<h3>带着问题学习</h3>

<ol>
<li>捕捉滚动鼠标滑轮事件</li>
<li>禁止事件</li>
<li>事件触发原理</li>
</ol>


<h3>在页面加载后执行任务</h3>

<ol>
<li>代码执行的时机选择</li>
</ol>


<p>$(document).ready()</p>

<blockquote><p>什么是加载完成
  一般来书，使用$(document).ready()要由于使用onload()事件处理程序，但必须要明确一点的是，
  因为支持文件可能还没有加载完成，所以类似图像的高度和宽度这样的属性此时则还不一定会有效。
  如果需要访问这些属性，就需要选择实现一个onload事件处理程序($(document).load())。</p></blockquote>

<ol>
<li>缩短代码的简写方式</li>
</ol>


<p>$(docuemnt).ready(function(){
    ...
});</p>

<p>等同于(万恶的...)</p>

<p>$(function(){
    ...
});</p>

<h2>第5章 操作DOM</h2>

<h3>操作属性</h3>

<p>操作class属性的方法：</p>

<ol>
<li>.addClass() 创建或增加这个属性</li>
<li>.removeClass() 删除或缩短该属性</li>
<li>.toggleClass() 交替的添加和移除一个类</li>
</ol>

]]></content:encoded>
    </item>
    
    <item>
      <title>SAE开发记录</title>
      <link href="/jinguodong-blog/2015/02/SAE/"/>
      <pubDate>2015-02-07T00:00:00+08:00</pubDate>
      <author>guodong.j</author>
      <guid>/jinguodong-blog/2015/02/SAE</guid>
      <content:encoded><![CDATA[<h2>SAE</h2>
]]></content:encoded>
    </item>
    
    <item>
      <title>JavaScript高级程序设计（第三版）</title>
      <link href="/jinguodong-blog/2015/02/Professional-JavaScript/"/>
      <pubDate>2015-02-07T00:00:00+08:00</pubDate>
      <author>guodong.j</author>
      <guid>/jinguodong-blog/2015/02/Professional-JavaScript</guid>
      <content:encoded><![CDATA[<h2>需要解决的问题</h2>

<ol>
<li>鼠标滚动事件处理。</li>
<li>图片块区滚动效果处理。</li>
<li>JavaScript实现网站模块式开发。</li>
</ol>


<h2>第一章 JavaScript简介</h2>

<h3>DOM级别</h3>

<p>DOM1级：</p>

<pre><code>包括DOM核心（DOM Core）和DOM HTML两个模块。其中DOM核心规定的是如何映射基于XML的文档结构，一边对文档中任意部分的访问和操作。DOM HTML模块则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法。
</code></pre>

<p>DOM2级：</p>

<pre><code>DOM2级在原来的基础上又扩充了鼠标和用户界面事件、范围、遍历（迭代DOM文档的方法）等细分模块，而且通过对象接口增加了对CSS的支持。
</code></pre>

<p>DOM2级引入了下列新模块：</p>

<blockquote><ol>
<li>DOM视图（DOM Views）：定义了跟踪不同文档（例如，应用CSS之前和之后的文档？）视图的借口。</li>
<li>DOM事件（DOM Events）：定义了事件和事件处理的接口。</li>
<li>DOM样式（DOM Style）：定义了基于CSS为元素应用样式的接口。</li>
<li>DOM遍历和范围（DOM Traversal and Range）：定义了遍历和操作文档树的接口。</li>
</ol>
</blockquote>

<p>DOM3级：</p>

<pre><code>进一步扩展了DOM，引入了以统一方式加载和保存文档的方法---在DOM加载和保存（DOM Load and Save）模块中定义；新增验证文档的方法---在DOM验证（DOM Validation）模块中定义）等。
</code></pre>

<h3>浏览器对象模型（BOM）</h3>

<pre><code>根本上讲，BOM只处理浏览器窗口和框架；但人们习惯把所有针对浏览器的JS扩展都算做BOM的一部分。
</code></pre>

<p>BOM的一些扩展功能：</p>

<ol>
<li>弹出新浏览器窗口的功能；</li>
<li>移动、缩放和关闭浏览器窗口的功能；</li>
<li>提供浏览器详细信息的navigator对象；</li>
<li>提供浏览器所加载页面下的详细信息的location对象；</li>
<li>提供用户显示器分辨率详细信息的screen对象；</li>
<li>对cookies的支持；</li>
<li>想XMLHttpRequest和IE的ActiveXObject这样的自定义对象。</li>
</ol>


<h3>小结（2015-02-07）</h3>

<p>JavaScript有以下三个不同的部分组成：</p>

<ol>
<li>ECMAScript，提供核心语言功能；</li>
<li>文档对象模型DOM，提供访问和操作页面内容的方法和接口；</li>
<li>浏览器对象模型，提供与浏览器交互的方法和接口。</li>
</ol>


<h2>第二章 在HTML中使用JavaScript</h2>

<pre><code>&lt;script type="text/javascript" src="jjj.js"&gt;&lt;/script&gt;

？？？后续补充
</code></pre>

<h2>第三章 基本概念</h2>

<h3>本章内容</h3>

<ol>
<li>语法</li>
<li>数据类型</li>
<li>流控制语句</li>
<li>函数</li>
</ol>


<h3>带着问题学习</h3>

<ol>
<li><p>函数的定义：</p>

<p> 基本形式：
 function funcName(arg1, arg2){
     statements
 }
 理解参数：</p>

<ol>
<li>函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数</li>
<li>没有传递值的命名参数将自动被赋予undefined值（定义了变量但是没有初始化）。</li>
</ol>
</li>
<li><p>for in 循环的使用：</p>

<p> for-in是一种精准的迭代语句，用来枚举对象的属性。
 for (var param_name in expression){
     statements;
 }</p>

<p> ？？？后续补充</p></li>
</ol>


<h2>第四章 变量、作用域和内存问题</h2>

<h3>本章内容</h3>

<ol>
<li>理解基本类型和引用类型的值</li>
<li>理解执行环境</li>
<li><p>理解垃圾收集</p>

<p> ？？？后续补充</p></li>
</ol>


<h2>第五章 引用类型</h2>

<h3>本章内容</h3>

<ol>
<li>使用对象</li>
<li>创建并操作数组</li>
<li>理解基本的JS类型</li>
<li><p>使用基本类型和基本包装类型</p>

<p> ？？？后续补充</p></li>
</ol>


<h2>第六章 面向对象的程序设计</h2>

<h3>本章内容</h3>

<ol>
<li>理解对象属性</li>
<li>理解并创建对象</li>
<li><p>理解继承</p>

<p> ？？？后续补充</p></li>
</ol>


<h2>第七章 函数表达式</h2>

<h3>本章内容</h3>

<ol>
<li>函数表达式的特征</li>
<li>使用函数实现递归</li>
<li><p>使用闭包定义私有变量</p>

<p> ？？？ 后续补充</p></li>
</ol>


<h2>第八章 BOM</h2>

<h3>本章内容</h3>

<ol>
<li>理解window对象————BOM的核心</li>
<li>控制窗口、框架和弹出窗口</li>
<li>利用location对象中的页面信息</li>
<li><p>使用navigator对象了解浏览器</p>

<p> ？？？后续补充</p></li>
</ol>


<h2>第九章 客户端检测</h2>

<h3>本章内容</h3>

<ol>
<li>使用能力检测</li>
<li>用户代理检测的历史</li>
<li><p>选择检测方式</p>

<p> ？？？后续补充</p></li>
</ol>


<h2>第十章 DOM</h2>

<h3>本章内容</h3>

<ol>
<li>理解包含不同层次节点的DOM</li>
<li>使用不同的节点类型</li>
<li><p>克服浏览器兼容性问题及各种陷阱</p>

<p> ？？？后续补充</p></li>
</ol>


<h2>第十一章 DOM扩展</h2>

<h3>本章内容</h3>

<ol>
<li>理解Selectors API</li>
<li>使用HTML5 DOM扩展</li>
<li><p>使用专有的DOM扩展</p>

<p> ？？？马上补充</p></li>
</ol>


<h2>第十二章 DOM2和DOM3</h2>

<h3>本章内容</h3>

<ol>
<li>DOM2和DOM3的变化</li>
<li>操作样式的DOM API</li>
<li><p>DOM遍历与范围</p>

<p> ？？？后续补充</p></li>
</ol>


<h2>第十三章 事件</h2>

<h3>本章内容</h3>

<ol>
<li>理解事件流</li>
<li>使用事件处理程序</li>
<li>不同的事件类型</li>
</ol>


<h3>事件流</h3>

<pre><code>事件流概念分为两种：事件冒泡流（被普遍支持）；事件捕获流。
</code></pre>

<h4>DOM事件流</h4>

<p><img src="http://www.17jquery.com/uploads/allimg/c110106/12942Y5150Z-550T.jpg" alt="" /></p>

<h3>事件处理程序</h3>

<h4>HTML事件处理程序：</h4>

<pre><code>&lt;input type="button" value="Click Me" on click="alert('Clicked')" /&gt;
由于onclick特性将JavaScript代码作为其值来定义的。因此不能在其中使用未经转义的HTML语法字符，如：&amp;, "", &lt;, &gt;。
</code></pre>

<p>这样指定事件处理程序具有一些独到之处。首先，会创建一个封装着元素属性值的函数。这个函数中有一个局部变量event，也就是事件对象。</p>

<pre><code>&lt;input type="button" value="click me", onclick="alert(event.type)"/&gt;
</code></pre>

<p>在这个函数内部，this值等于事件的目标元素。</p>

<p>关于这个动态创建的函数，另一个有意思的地方是它扩展作用域的方式。</p>

<pre><code>function(){
    with(document){
        with(this){

        }
    }
}
&lt;input type="button" value="click me", onclick="alert(value)"/&gt;
</code></pre>

<p>缺点：有两个。
+ 存在时差问题。</p>

<pre><code>通过try-catch块解决。
&lt;input type="button" value="click me", onclick="try{showMsg();}catch(ex){}"/&gt;
</code></pre>

<ul>
<li>这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果</li>
<li>通过HTML指定事件处理程序的最后一个缺点是HTML与JavaScript代码紧密耦合。</li>
</ul>


<h4>DOM0级事件处理程序</h4>

<p>通过JavaScript指定时间处理程序的传统方式，将一个函数赋值给一个事件处理程序属性。</p>

<pre><code>var btn = document.getElementById("myBtn");
btn.onclick = function(){
    alter("Clicked");
}
</code></pre>

<p>使用DOM0级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行，程序中的this引用当前元素。</p>

<pre><code>var btn = document.getElementById("myBtn");
btn.onclick = function(){
    alter(this.id);
}
</code></pre>

<p>也可以删除DOM0级方法指定的事件处理程序：
    btn.onclick = null;</p>

<h4>DOM2级事件处理程序</h4>

<p>提供两个方法：用于指定和删除事件处理程序的操作，addEventListener()和removeEventListener()。所有DOM节点都包含这两个方法，并且它们都接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后的这个布尔值如果为true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。</p>

<p>通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；</p>

<p>大多数情况下，布尔值应设置为false，最大限度的兼容各种浏览器。</p>

<pre><code>IE9, Firefox, Safari, Chrome和Opera支持DOM2级事件处理程序。
</code></pre>

<h4>IE事件处理程序</h4>

<p>IE实现了DOM中类似的两个方法，attachEvent()和detachEvent()。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。由于IE8及更早的版本只支持事件冒泡，所以通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段。</p>

<pre><code>var btn = document.getElementById("myBtn");
btn.attachEvent("onclick", function(){
    alter(this.id);
});
</code></pre>

<p>在IE中使用attachEvent()与使用DOM0级方法的主要区别在于事件处理程序的作用域。</p>

<pre><code>在使用attachEvent()方法的情况下，事件处理程序会在全局作用域中进行，因此this和window相同。

addEventListener()与attachEvent()类似，可以用来为一个元素添加多个事件处理程序。但是attachEvent()以添加它们的相反的顺序执行。
</code></pre>

<h4>跨浏览器的事件处理程序</h4>

<p>要确保处理事件的代码能在大多数浏览器下一致的运行，只需要关注冒泡阶段。</p>

<pre><code>var EventUtil= {
    addHandler: function(element, type, handler){
        if(element.addEventListener){
            element.addEventLister(type, handler, false);
        }else if(element.attachEvent){
            element.attachEvent("on" + type, handler);
        }else{
            element["on"+type] = handler;
        }
    },
    removeHandler: function(element, type, handler){
        if(element.removeEventListener){
            element.removeEventListener(type, handler, false);
        }else if(element.detachEvent){
            element.detachEvent("on" + type, handler);
        }else{
            element["on" + type] = null;
        }
    }
}
</code></pre>

<p>注意： DOM0级对每个事件只支持一个事件处理程序。</p>

<h3>事件对象</h3>

<blockquote><p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象包含着所有与事件有关的信息。
包括事件的元素、事件的类型以及其他与特定事件相关的信息。</p></blockquote>

<h4>DOM中的事件对象</h4>

<p>|属性方法|类型|读/写|说明|
|:------:|:--:|:---:|:--:|
|bubbles|Boolean|只读|表明事件是否冒泡|
|currentTarget|Element|只读|其事件处理程序当前正在处理事件的那个元素|
|preventDefault()|Function|只读|取消事件的默认行为。如果cancelable是true，则可以使用这个方法|
|stopPropagation()|Function|只读|取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3级事件中新增）|
|target|Element|只读|事件的目标|
...待添加</p>

<p>在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。</p>

<p>如果需要通过一个函数处理多个事件时，可以通过type属性。</p>

<pre><code>var btn = document.getElementById("myBtn");
var handler = function(event){
    switch(event.type){
        case "click":
            break;
        case "mouseover":
            break;
        case "mouseout":
            break;
    }
};
btn.onclick = handler;
btn.onmouseover = handler;
btn.onmouseout = handler;
</code></pre>

<blockquote><p>要阻止特定事件的默认行为，可以重用preventDefault()方法。例如，链接的默认行为就是在被单击时会导航到其href特定指定的URL。</p>

<p>只有cancelable是行为true是，才可以使用preventDefault()来取消其默认行为。</p>

<p>另外，stopPropagation()方法用于立即停止事件在DOM层次中的传播。</p></blockquote>

<h4>IE中的事件对象</h4>

<p>待添加</p>

<h4>跨浏览器的事件对象</h4>

<pre><code>var EventUtil = {
    addHandler: function(element, type, handler){
        ...
    },
    getEvent: function(event){
        return event? event: window.event;
    },
    getTarget: function(event){
        return event.target || event.srcElement;
    },
    preventDefault: function(event){
        if(event.preventDefault){
            event.preventDefault();
        }else{
            event.returnValue = false;
        }
    },

    removeHandler: function(element, type, handler){
        ...
    },

    stopPropagation: function(event){
        if(event.stopPropagation){
            event.stopPropagation();
        }else{
            event.cancelBubble = true;
        }
    }
};
</code></pre>

<h3>事件类型</h3>

<p>类型归纳：</p>

<ol>
<li>UE事件，当用户与页面上的元素交互式触发；</li>
<li>焦点事件，当元素获得或失去焦点时触发；</li>
<li>鼠标事件，当用户通过鼠标在页面上执行操作时触发；</li>
<li>滚轮事件，当使用鼠标滚轮时触发；</li>
<li>文本事件，当在文档中输入文本时触发；</li>
<li>键盘事件，当用户通过键盘在页面上执行操作时触发；</li>
<li>合成事件，</li>
<li>变动事件，当底层DOM结构发生变化时触发。</li>
</ol>


<h4>UI事件</h4>

<h3>内存和性能</h3>

<h3>模拟事件</h3>

<h3>小结</h3>

<h3>带着问题学习</h3>

<ol>
<li>利用鼠标的滚动事件实现整页滚动效果。</li>
<li>iscroll插件，内部元素拖拽影响到外部元素的拖拽，禁止拖拽事件外传？</li>
<li><a href="http://www.w3cplus.com/source/10-best-Parallax-Scrolling-plugin.html">10个优秀视差滚动插件</a></li>
</ol>


<h2>表单脚本</h2>

<h2>使用Canvas绘图</h2>

<h2>HTML5脚本编程</h2>

<h2>错误处理与调试</h2>

<h2>JavaScript与DML</h2>
]]></content:encoded>
    </item>
    
    <item>
      <title>JavaScript DOM编程艺术</title>
      <link href="/jinguodong-blog/2015/02/JS-DOM/"/>
      <pubDate>2015-02-01T00:00:00+08:00</pubDate>
      <author>guodong.j</author>
      <guid>/jinguodong-blog/2015/02/JS-DOM</guid>
      <content:encoded><![CDATA[<h2>第一章 JavaScript简史</h2>

<h3>JavaScript的由来：</h3>

<pre><code>由Netscape与Sun公司合作开发，也叫做ECMAScript语言。
</code></pre>

<h3>DHTML(HTML+CSS+JS)</h3>

<p>背后的含义：</p>

<blockquote><ol>
<li>利用HTML把网页标记为各种元素。</li>
<li>利用CSS设置元素样式和它们的显示位置。</li>
<li>利用JSavaScript实时地操控页面和改变样式。</li>
</ol>
</blockquote>

<h3>DOM(文档对象模型)</h3>

<p>DOM是一种API，一个与系统平台和编程语言无关的接口。</p>

<h2>第二章 JavaScript语法</h2>

<h3>准备工作</h3>

<pre><code>最好将&lt;script&gt;标签放到HTML文档的最后，&lt;/body&gt;标签之前。
这样能是浏览器更快的加载。
</code></pre>

<h3>语法</h3>

<ol>
<li><p>语句</p>

<p> 建议在每条语句的末尾都加上一个分号，一种良好的编程习惯：
 first statement;
 second statement;</p></li>
<li><p>注释</p>

<p> // 注释是个好习惯。
 /<em> 好习惯
     好习惯 </em>/
 &lt;!-- 好习惯</p></li>
<li><p>变量</p></li>
</ol>


<blockquote><ol>
<li>提前声明变量，是一种良好的编程习惯。</li>
<li>变量和其他语法元素的名字都是区分字母大小写的。</li>
<li>不容许变量名中包括空格或标点符号。</li>
<li>变量名容许包含字幕、数组、美元符号和下划线。</li>
<li>驼峰式是函数名、方法名和对象属性名命名的首选格式。</li>
</ol>
</blockquote>

<h3>数据类型</h3>

<ul>
<li>字符串</li>
<li>数值</li>
<li>布尔值</li>
<li>数组+关联数组</li>
<li>对象</li>
</ul>


<h3>操作</h3>

<ul>
<li>算数操作</li>
</ul>


<h3>条件语句</h3>

<ul>
<li>if (true) {};</li>
<li>比较操作符
-- 相等操作符==认为空字符串与false的含义相同
-- 全等操作符===会执行更严格的比较，不仅比较值，也会比较变量的类型。</li>
<li>逻辑操作符</li>
</ul>


<h3>循环语句</h3>

<ul>
<li>while循环</li>
<li>for循环</li>
</ul>


<h3>函数</h3>

<pre><code>function name(arg1, arg2){
    statement;
    return res;
}
</code></pre>

<h3>变量的作用域</h3>

<p>局部变量：函数内作用域。</p>

<pre><code>只用好的编程习惯，在第一次对某个变量赋值时，应该用var对其作出声明。
</code></pre>

<h3>对象</h3>

<p>方法和属性</p>

<pre><code>var jeremy = new Person();
jeremy.name = "name";
jeremy.age = 32;
</code></pre>

<ol>
<li><p>内建对象</p>

<p> var beatles = new Array();
 var num = 7.651;
 var num = Math.round(num);
 var = current_time = new Date();
 var today = current_time.getDay();</p></li>
<li><p>宿主对象</p>

<p> 一些已经预先定义好的其他对象，这些对象不是都有JavaScript语言本身而是由它的运行环境提供。比如Web应用中的浏览器。</p>

<p> 宿主对象包括document, From, Image和Element等。</p></li>
</ol>

]]></content:encoded>
    </item>
    
  </channel>
</rss>
